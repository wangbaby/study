== == == == == == == == == == == == == == == == == == == == == == == == == == ==
    == == == == 统一的初始化 == == == == == == == == == == == == == == == == ==
    == == == == == == == == == == == == == ==

    为了统一初始化方式，并且让初始化行为具有确定的效果，C++ 11中提出了列表初始化（List -
        initialization）的概念。 对于普通数组和POD类型，C++ 98 /
            03可以使用初始化列表（initializer list）进行初始化： int i_arr[3] =
    {1, 2, 3};
long l_arr[] = {1, 3, 2, 4};
struct A {
  int x;
  int y;
} a = {1, 2};
但是这种初始化方式的适用性非常狭窄，只有上面提到的这两种数据类型可以使用初始化列表。

    在C++ 11中，初始化列表的适用性被大大增加了。它现在可以用于任何类型对象的初始化 class
    Foo {
 public:
  Foo(int) {}

 private:
  Foo(const Foo&);
};
Foo a1(123);   // 直接初始化
Foo a2 = 123;  // 拷贝初始化 error: 'Foo::Foo(const Foo &)' is private
Foo a3 = {123};
Foo a4{123};
int a5 = {3};
int a6{3};
在上例中，a3、a4使用了新的初始化方式来初始化对象，效果如同a1的直接初始化。 a5、a6则是基本数据类型的列表初始化方式。可以看到，它们的形式都是统一的。 这里需要注意的是，a3虽然使用了等于号，但它仍然是列表初始化，因此，私有的拷贝构造并不会影响到它。 a4和a6的写法，是C++ 98 /
    03所不具备的。在C++ 11中，可以直接在变量名后面跟上初始化列表，来进行对象的初始化。 这种变量名后面跟上初始化列表方法同样适用于普通数组和POD类型的初始化： int
        i_arr[3]{1, 2, 3};  // 普通数组
struct A {
  int x;
  struct B {
    int i;
    int j;
  } b;
} a{1, {2, 3}};  // POD 类型
在初始化时， {}
前面的等于号是否书写对初始化行为没有影响。

    另外，如同读者所想的那样，new操作符等可以用圆括号进行初始化的地方，也可以使用初始化列表： int*
        a = new int{123};
double b = double{12.12};
int* arr = new int[3]{1, 2, 3};
指针a指向了一个new操作符返回的内存，通过初始化列表方式在内存初始化时指定了值为123。 b则是对匿名对象使用列表初始化后，再进行拷贝初始化。 这里让人眼前一亮的是arr的初始化方式。堆上动态分配的数组终于也可以使用初始化列表进行初始化了。

    除了上面所述的内容之外，列表初始化还可以直接使用在函数的返回值上： struct
    Foo {
  Foo(int, double) {}
};
Foo func(void) { return {123, 321.0}; }
这里的return语句就如同返回了一个Foo（123，321 .0）。 由上面的这些例子可以看到，在C++ 11中使用初始化列表是非常便利的。它不仅统一了各种对象的初始化方式，而且还使代码的书写更加简单清晰。

    == == == == == == == == == == == == == == == == == == == == == == == == ==
    == == == == == == 对于一个自定义类型，初始化列表现在可能有两种执行结果 == ==
    == == == == == == == == == == == == == == == == == == == == == == == == ==
    == == == == struct A {
  int x;
  int y;
} a = {123, 321};  // a.x = 123, a.y = 321
struct B {
  int x;
  int y;
  B(int, int) : x(0), y(0) {}
} b = {123, 321};  // b.x = 0, b.y = 0
其实，上述变量a的初始化过程是C++ 98 /
    03中就有的聚合类型（Aggregates）的初始化。 它将以拷贝的形式，用初始化列表中的值来初始化struct
        A中的成员。 struct
    B由于定义了一个自定义的构造函数，因此，实际上初始化是以构造函数进行的。 看到这里，读者可能会希望能够有一个确定的判断方法，能够清晰地知道初始化列表的赋值方式。 具体来说，在使用初始化列表时，对于什么样的类型C++ 会认为它是一个聚合体？
        下面来看看聚合类型的定义： （1）类型是一个普通数组（如int[10]、char[]、long
            [2]
            [3] ）。 对于数组而言，情况是很清晰的。只要该类型是一个普通数组，哪怕数组的元素并非一个聚合类型，这个数组本身也是一个聚合类型： int
                x[] = {1, 3, 5};
float y[4][3] = {
    {1, 3, 5},
    {2, 4, 6},
    {3, 5, 7},
};
char cv[4] = {'a', 's', 'd', 'f'};
std::string sa[3] = {"123", "321", "312"};
（2）类型是一个类（class、struct、union），且
    ·无用户自定义的构造函数。 ·无私有（Private）或保护（Protected）的非静态数据成员。 ·无基类。 ·无虚函数。 ·不能有 {
}
和 =
    直接初始化（brace - or
    -equal -
        initializer）的非静态数据成员。 对于上述非聚合类型的情形，想要使用初始化列表的方法就是自定义一个构造函数

            需要注意的是，聚合类型的定义并非递归的。 简单来说，当一个类的非静态成员是非聚合类型时，这个类也有可能是聚合类型。比如下面这个例子： struct
        ST {
  int x;
  double y;

 private:
  int z;
};
ST s{1, 2.5, 1};  // error
struct Foo {
  ST st;
  int x;
  double y;
};
Foo foo{{}, 1, 2.5};  // OK
可以看到，ST并非一个聚合类型，因为它有一个Private的非静态成员。 但是尽管Foo含有这个非聚合类型的非静态成员st，它仍然是一个聚合类型，可以直接使用初始化列表。 注意到foo的初始化过程，对非聚合类型成员st做初始化的时候，可以直接写一对空的大括号“{
}
”，相当于调用ST的无参构造函数。

    对于聚合类型，使用初始化列表相当于对其中的每个元素分别赋值；
        而对于非聚合类型，则需要先自定义一个合适的构造函数，此时使用初始化列表将调用它对应的构造函数。

    == == == == == == == == == == == == == == == == == == == == == == == == ==
    == == == == == == 任意长度的初始化列表 std::initializer_list == == == == ==
    == == == == == == == == == == == == == == == == == == == == == == == == ==
    ==

    C++ 11中的stl容器拥有和未显示指定长度的数组一样的初始化能力,
    是通过使用std::initializer_list这个轻量级的类模板来完成上述功能支持的
        它是一个轻量级的容器类型，内部定义了iterator等容器必需的概念
            对于std：：initializer_list而言，它可以接收任意长度的初始化列表，但要求元素必须是同种类型T（或可转换为T）。 它有3个成员接口：size（）、begin（）、end（）。 它只能被整体初始化或赋值
                对std：：initializer_list的访问只能通过begin（）和end（）进行循环遍历，遍历时取得的迭代器是只读的。 因此，无法修改std：：initializer_list中某一个元素的值，但是可以通过初始化列表的赋值对std：：initializer_list做整体修改，代码如下：
                    std::initializer_list<int>
                        list;
size_t n = list.size();  // n == 0
list = {1, 2, 3, 4, 5};
n = list.size();  // n == 5
list = {3, 1, 2, 4};
n = list.size();  // n == 4
std::拥有一个无参数的构造函数，因此，它可以直接定义实例，此时将得到一个空的std::
    initializer_list
        之后，我们对std：：initializer_list进行赋值操作（注意，它只能通过初始化列表赋值）
            可以发现std::initializer_list：initializer_list被改写成了 {
  1，2，3，4，5
}
。 然后，还可以对它再次赋值，std：：initializer_list被修改成了{3，1，2，4}

看到这里，可能有读者会关心std：：initializer_list的传递或赋值效率。 假如std::
    在传递或赋值的时候如同vector之类的容器一样，把每个元素都复制了一遍，那么使用它传递类对象的时候就要斟酌一下了。 实际上，std：：initializer_list是非常高效的。它的内部并不负责保存初始化列表中元素的拷贝，仅仅存储了列表中元素的引用而已。 因此，我们不应该像这样使用：
        std::initializer_list<int>
        func(void) {
  int a = 1, b = 2;
  return {a, b};  // a、b在返回时并没有被拷贝
}
虽然这能够正常通过编译，但却无法传递出我们希望的结果（a、b在函数结束时，生存期也结束了，因此，返回的将是不确定的内容）。 这种情况下最好的做法应该是这样：
    std::vector<int>
    func(void) {
  int a = 1, b = 2;
  return {a, b};
}
使用真正的容器，或具有转移 /
    拷贝语义的物件来替代std::initializer_list返回需要的结果。 我们应当总是把std::
        initializer_list看做保存对象的引用，并在它持有对象的生存期结束之前完成传递。

    std：：initializer_list不仅可以用来对自定义类型做初始化，还可以用来传递同类型的数据集合 class
    FooVector {
  std::vector<int> content_;

 public:
  FooVector(std::initializer_list<int> list) {
    for (auto it = list.begin(); it != list.end(); ++it) {
      content_.push_back(*it);
    }
  }
};
class FooMap {
  std::map<int, int> content_;
  using pair_t = std::map<int, int>::value_type;

 public:
  FooMap(std::initializer_list<pair_t> list) {
    for (auto it = list.begin(); it != list.end(); ++it) {
      content_.insert(*it);
    }
  }
};
FooVector foo_1 = {1, 2, 3, 4, 5};
FooMap foo_2 = {{1, 2}, {3, 4}, {5, 6}};
void func(std::initializer_list<int> l) {
  for (auto it = l.begin(); it != l.end(); ++it) {
    std::cout << *it << std::endl;
  }
}
func({});         // 一个空集合
func({1, 2, 3});  // 传递 { 1, 2, 3 }

== == == == == == == == == == == == == == == == == == == == == == == == == == ==
    == == == == 防止类型收窄 == == == == == == == == == == == == == == == == ==
    == == == == == == == == == == == == == ==
    类型收窄指的是导致数据内容发生变化或者精度丢失的隐式类型转换。 具体来说，类型收窄包括以下几种情况： 1）从一个浮点数隐式转换为一个整型数，如int i =
    2.2。 2）从高精度浮点数隐式转换为低精度浮点数，如从long double隐式转换为double或float。 3）从一个整型数隐式转换为一个浮点数，并且超出了浮点数的表示范围，如float x =
        （unsigned long long） -
        1。 4）从一个整型数隐式转换为一个长度较短的整型数，并且超出了长度较短的整型数的表示范围，如char x =
            65536。 在C++ 98 /
            03中，像上面所示类型收窄的情况，编译器并不会报错（或报一个警告，如Microsoft Visual
                C++ ）。 这往往会导致一些隐藏的错误。在C++ 11中，可以通过列表初始化来检查及防止类型收窄。