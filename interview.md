说下ARP 协议的工作过程？
ARP 协议协议，Address Resolution Protocol，地址解析协议，它是用于实现IP地址到MAC地址的映射。
首先，每台主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址的对应关系。
当源主机需要将一个数据包要发送到目的主机时，会首先检查自己的ARP列表，是否存在该IP地址对应的MAC地址；如果有﹐就直接将数据包发送到这个MAC地址；如果没有，就向本地网段发起一个ARP请求的广播包，查询此目的主机对应的MAC地址。此ARP请求的数据包里，包括源主机的IP地址、硬件地址、以及目的主机的IP地址。
网络中所有的主机收到这个ARP请求后，会检查数据包中的目的IP是否和自己的IP地址一致。如果不相同，就会忽略此数据包；如果相同，该主机首先将发送端的MAC地址和IP地址添加到自己的ARP列表中，如果ARP表中已经存在该IP的信息，则将其覆盖，然后给源主机发送一个 ARP响应数据包，告诉对方自己是它需要查找的MAC地址。
源主机收到这个ARP响应数据包后，将得到的目的主机的IP地址和MAC地址添加到自己的ARP列表中，并利用此信息开始数据的传输。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。

Shadowsocks
说下ping的原理
ping，Packet Internet Groper，是一种因特网包探索器，用于测试网络连接量的程序。Ping是工作在TCP/IP网络体系结构中应用层的一个服务命令， 主要是向特定的目的主机发送ICMP（Internet Control Message Protocol 因特网报文控制协议） 请求报文，测试目的站是否可达及了解其有关状态”
一般来说，ping可以用来检测网络通不通。它是基于ICMP协议工作的。假设机器A ping机器B，工作过程如下：
ping通知系统，新建一个固定格式的ICMP请求数据包
ICMP协议，将该数据包和目标机器B的IP地址打包，一起转交给IP协议层
IP层协议将本机IP地址为源地址，机器B的IP地址为目标地址，加上一些其他的控制信息，构建一个IP数据包
先获取目标机器B的MAC地址。
数据链路层构建一个数据帧，目的地址是IP层传过来的MAC地址，源地址是本机的MAC地址
机器B收到后，对比目标地址，和自己本机的MAC地址是否一致，符合就处理返回，不符合就丢弃。
根据目的主机返回的ICMP回送回答报文中的时间戳，从而计算出往返时间
最终显示结果有这几项：发送到目的主机的IP地址、发送 & 收到 & 丢失的分组数、往返时间的最小、最大& 平均值


进程什么时候由用户态转化为内核态？
(系统调用、中断、陷入)
线程和进程，线程可以共享进程里的哪些东西。 知道协程是什么吗
进程，是并发执行的程序在执行过程中分配和管理资源的基本单位，每一个进程都有一个自己的地址空间，即进程空间或（虚空间）。进程空间的大小 只与处理机的位数有关，一个 16 位长处理机的进程空间大小为 216 ，而 32 位处理机的进程空间大小为 232 。进程至少有 5 种基本状态，它们是：初始态，执行态，等待状态，就绪状态，终止状态。
线程，在网络或多用户环境下，一个服务器通常需要接收大量且不确定数量用户的并发请求，为每一个请求都创建一个进程显然是行不通的，——无论是从系统资源开销方面或是响应用户请求的效率方面来看。因此，操作系统中线程的概念便被引进了。线程，是进程的一部分，一个没有线程的进程可以被看作是单线程的。线程有时又被称为轻权进程或轻量级进程，也是 CPU 调度的一个基本单位。
共享进程的地址空间，全局变量（数据和堆）。在一个进程中，各个线程共享堆区，而进程中的线程各自维持自己的栈。
Each thread has its own:
•  栈区和栈指针（Stack area and stack pointer）
•  寄存器（Registers）
•  调度优先级Scheduling properties (such as policy or priority)
•  信号（阻塞和悬挂）Signals (pending and blocked signals)
•  普通变量Thread specific data ( automatic variables )
线程是指进程内的一个执行单元,也是进程内的可调度实体.
与进程的区别:
(1)地址空间:进程内的一个执行单元;进程至少有一个线程;它们共享进程的地址空间;而进程有自己独立的地址空间;
(2)资源拥有:进程是资源分配和拥有的单位,同一个进程内的线程共享进程的资源
(3)线程是处理器调度的基本单位,但进程不是.
4)二者均可并发执行.
进程和线程都是由操作系统所体会的程序运行的基本单元，系统利用该基本单元实现系统对应用的并发性。进程和线程的区别在于：
简而言之,一个程序至少有一个进程,一个进程至少有一个线程.
线程的划分尺度小于进程，使得多线程程序的并发性高。
另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。
线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。
从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。
进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.
线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.
一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行.
协程：
定义：协程其实可以认为是比线程更小的执行单元。为啥说他是一个执行单元，因为他自带CPU上下文。
协程切换：协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。
（我们在自己在进程里面完成逻辑流调度，碰着i\o我就用非阻塞式的。那么我们即可以利用到异步优势，又可以避免反复系统调用，还有进程切换造成的开销，分分钟给你上几千个　　　　逻辑流不费力。这就是协程。）
协程的调度完全由用户控制，一个线程可以有多个协程，用户创建了几个线程，然后每个线程都是循环按照指定的任务清单顺序完成不同的任务，当任务被堵塞的时候执行下一个任务，当恢复的时候再回来执行这个任务，任务之间的切换只需要保存每个任务的上下文内容，就像直接操作栈一样的，这样就完全没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快；另外协程还需要保证是非堵塞的且没有相互依赖，协程基本上不能同步通讯，多采用一步的消息通讯，效率比较高。
多线程和多进程的优劣：
多线程还是多进程的争执由来已久，这种争执最常见到在B/S通讯中服务端并发技术的选型上，比如WEB服务器技术中，Apache是采用多进程的（perfork模式，每客户连接对应一个进程，每进程中只存在唯一一个执行线程），Java的Web容器Tomcat、Websphere等都是多线程的（每客户连接对应一个线程，所有线程都在一个进程中）


对于C/C++编写的程序，从源代码到可执行文件，一般经过下面四个步骤：
1).预处理，产生.i文件
2).编译，产生汇编文件(.s文件)
3).汇编，产生目标文件(.o或.obj文件)
4).链接,产生可执行文件(.out或.exe文件)


执行main函数之前和之后做了哪些工作？
main函数执行之前主要是系统的初始化资源：
在栈区：设置栈指针
在data段：初始化全局变量和静态变量
在bss段：对未初始化的全局变量进行赋初值，bool是false,short,int,long 是0，指针是NULL
将main函数的参数传到main函数里面
main函数执行完成之后并不一定意味着进程结束。
main函数执行完成之后：
全局对象的析构函数会在main函数的执行后执行
使用atexit注册的函数会在main函数执行之后执行
为什么构造函数不能是虚函数？

malloc的实现方案：
1）malloc 函数的实质是它有一个将可用的内存块连接为一个长长的列表的所谓空闲链表。
2）调用 malloc（）函数时，它沿着连接表寻找一个大到足以满足用户请求所需要的内存块。 然后，将该内存块一分为二（一块的大小与用户申请的大小相等，另一块的大小就是剩下来的字节）。 接下来，将分配给用户的那块内存存储区域传给用户，并将剩下的那块（如果有的话）返回到连接表上。
3）调用 free 函数时，它将用户释放的内存块连接到空闲链表上。
4）到最后，空闲链会被切成很多的小内存片段，如果这时用户申请一个大的内存片段， 那么空闲链表上可能没有可以满足用户要求的片段了。于是，malloc（）函数请求延时，并开始在空闲链表上检查各内存片段，对它们进行内存整理，将相邻的小空闲块合并成较大的内存块。
brk和mmap：
从操作系统角度来看，进程分配内存有两种方式，分别由两个系统调用完成：brk和mmap（不考虑共享内存）.
这两种方式分配的都是虚拟内存，没有分配物理内存。在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系。
在标准C库中，提供了malloc/free函数分配释放内存，这两个函数底层是由brk，mmap，munmap这些系统调用实现的。


malloc最多能开多少
限制因素：
Lib C库的实现
操作系统
硬件
当前内存的使用状况。
具体不同Lib C库实现方式才是最主要的因素。
其次就是操作系统，操作系统的地址空间分布决定了用户可用的最大地址空间，比如32位Windows是用户2G+内核2G的地址空间分配方式，32位Linux是用户3G+内核1G，不同操作系统的实现方式，对malloc也是有影响的。
然后就是硬件，32位和64位的硬件限制肯定是不一样的，页表的支持情况（巨型页）也会对malloc有限制。
最后是当前内存使用情况，比如剩余内存，虚地址空间的碎片情况等等。

memcpy与memmove的区别
memcpy和memmove都是C语言的库函数，相比于strcpy和strncpy只能拷贝字符数组，memcpy与memmove可以拷贝其它类型的数组，但是为什么要同时提供两种方法呢？
首先来看函数原型：
void *memcpy(void *restrict s1, const void *restrict s2, size_t n);
void *memmove(void *s1, const void *s2, size_t n);
这两个函数都是将s2指向位置的n字节数据拷贝到s1指向的位置，区别就在于关键字restrict, memcpy假定两块内存区域没有数据重叠，而memmove没有这个前提条件。如果复制的两个区域存在重叠时使用memcpy，其结果是不可预知的，有可能成功也有可能失败的，所以如果使用了memcpy,程序员自身必须确保两块内存没有重叠部分。


如何确保对象在抛出异常时也能被删除？什么是RAII？
总的思想是RAII：设计一个class，令他的构造函数和析构函数分别获取和释放资源。
有两个方法：
利用“函数的局部对象无论函数以何种方式(包括因异常)结束都会被析构”这一特性，将“一定要释放的资源”放进局部对象的析构函数；
使用智能指针。

C++的内存管理方式
在c++中内存主要分为5个存储区：
栈（Stack）：局部变量，函数参数等存储在该区，由编译器自动分配和释放.栈属于计算机系统的数据结构，进栈出栈有相应的计算机指令支持，而且分配专门的寄存器存储栈的地址，效率高，内存空间是连续的，但栈的内存空间有限。
堆(Heap)：需要程序员手动分配和释放（new,delete），属于动态分配方式。内存空间几乎没有限制，内存空间不连续，因此会产生内存碎片。操作系统有一个记录空间内存的链表，当收到内存申请时遍历链表，找到第一个空间大于申请空间的堆节点，将该节点分配给程序，并将该节点从链表中删除。一般系统会在该内存空间的首地址处记录本次分配的内存大小，用于delete释放该内存空间。
全局/静态存储区:全局变量，静态变量分配到该区，到程序结束时自动释放，包括DATA段（全局初始化区）与BSS段（全局未初始化段）。其中，初始化的全局变量和静态变量存放在DATA段，未初始化的全局变量和静态变量存放在BSS段。
BSS段特点：在程序执行前BSS段自动清零，所以未初始化的全局变量和静态变量在程序执行前已经成为0.
文字常量区：存放常量，而且不允许修改。程序结束后由系统释放。
程序代码区：存放程序的二进制代码

 static的用法有哪些？
（1）修饰局部变量。局部变量的生存期为声明之后，直至当前代码块结束。若使用static声明，该变量将变为静态持续性，存放在静态存储区，存在于整个程序运行周期。同时保证每个进入该代码块，变量保持上一次退出时的值。
（2）修饰全局变量。会改变全局变量的链接性，使用static修饰后，全局变量由外部链接性变为内存链接性，这样其他源文件不能使用extern变量使用该变量，该变量只能在当前文件内共享访问。
（3）修饰函数。函数默认具有外部链接性，同普通全局变量一样。使用static修饰后，其他源文件不能使用extern来使用该函数。该函数为内部链接性，当前文件可访问。
（4）修饰成员变量。修饰成员变量后，该变量将不在类对象的内存布局当中，存在于静态存储区。该变量存在于类对象声明之前，即使没有任何一个类对象声明，该变量依然存在。所有的类对象共享一份实例。
（5）修饰成员函数。静态成员函数不能访问普通成员变量，只能访问静态成员变量。同时不需要通过类实例进行调用。

C++如何避免内存泄漏
解答：这其实可以看做是一个编程风格的问题。
a、使用RAII(Resource Acquisition Is Initialization,资源获取即初始化)技法，以构造函数获取资源(内存),析构函数释放。
b、相比于使用原生指针，更建议使用智能指针，尤其是C++11标准化后的智能指针。
c、注意delete和delete[]的使用方法。

C++中的转化机制？各适用于什么环境？dynamic_cast转换失败时，会出现什么情况？
对指针，返回NULL.对引用，抛出bad_cast异常more Effective C++
C++引入了4种类型转化操作符（cast operator）：static_cast，const_cast，dynamic_cast和reinterpret_cast，使用方法与C语言中略有不同：
(type)expression; //这是C语言的
然后引入C++的：
static_cast<type>(expression);//这是C++的
然后看一下各自的适用范围：
static_cast：static_cast基本上拥有与C旧式转型相同的威力和意义，以及相同的限制。但是，该类型转换操作符不能移除常量性，因为有一个专门的操作符用来移除常量性。
const_cast：用来改变表达式中的常量性（constness）或者易变形（volatileness），只能用于此功能。
dynamic_cast：将指向基类basic class object的pointer或者reference转型为指向派生类derived（或这sibling base）class object的pointer或者reference中，并且可以获知是否转型成功：如果转型失败，当转型对象是指针的时候会返回一个null指针；当转型对象是reference会抛出一个异常exception。dynamic_cast无法应用在缺乏虚函数的类型上，也不能改变类型的常量性。
此外，dynamic_cast还有一个用途就是找出被对象占用的内存的起始点。
reinterpret_cast：这个操作符的转换结果几乎总是和编译器平台相关，所以不具有移植性。reinterpret_cast的最常用用途是转换“函数指针”类型，



C++ vector和list的区别？
vector是动态数组实现的，一说到动态那肯定是在堆上分配空间的。如果容量超出原先设定的值，会以2倍扩增。性能上：因为是数组实现的，所以访问起来肯定是O(1)时间内访问。
因为是vector,所以会经常有插入和删除的操作：
如果在结尾插入并且空间够的情况下，很快，如果空间不够，则首先要进行扩容，扩容的过程中完成内存拷贝。在中间拷贝也是一样，如果空间足够大，只需要完成插入位置后的元素拷贝就行了，如果内存不够则也需要先进行扩容，然后进行拷贝。
如果删除的是结尾的元素的话很快就可以完成，如果是中间的元素那就需要拷贝了。
总体而言由于vector的特性原因，所以它很适合随机访问，并且插入删除在结尾部。
list是双向链表实现的，由于是双向链表，所以肯定也是在堆上分配空间的。
那自然插入和删除都是很容易的，因为双向链表实现的原理就是为了插入和删除。
具体的区别和联系：
都是在堆上分配空间
vector是基于动态数组实现的，list基于双向链表实现的
vector不便于中间插入和删除，list支持随机插入和删除

虚函数表：
多态是由虚函数实现的，而虚函数主要是通过虚函数表（V-Table）来实现的。
如果一个类中包含虚函数（virtual修饰的函数），那么这个类就会包含一张虚函数表，虚函数表存储的每一项是一个虚函数的地址。如下图：
这个类的每一个对象都会包含一个虚指针（虚指针存在于对象实例地址的最前面，保证虚函数表有最高的性能），这个虚指针指向虚函数表。
注：对象不包含虚函数表，只有虚指针，类才包含虚函数表，派生类会生成一个兼容基类的虚函